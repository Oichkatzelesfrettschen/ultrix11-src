ANC	2.head.c	/^#define ANC(v,w)	(ntobef[v] <= ntobef[w] && ntoaft/
ARC	def.h	/^#define ARC(v,i)	*arc(v,i)$/
ARCCOUNT	3.loop.c	/^#define ARCCOUNT(v)	REACH(v)$/
ARCNUM	def.h	/^#define ARCNUM(v)	*((arcsper[NTYPE(v)] >= 0) ? &ar/
ASSERT	beauty.y	/^#define ASSERT(X,Y)	if (!(X)) error("struct bug: a/
BACKEDGE	2.dfs.c	/^#define BACKEDGE(e)	(e < -1)$/
BEGCODE	def.h	/^#define BEGCODE(v)	*stlfmt(v,0)		\/* 1st char of li/
BEGCOM	def.h	/^#define BEGCOM(v)	graph[v][1]$/
BRANCHTYPE	3.flow.c	/^#define BRANCHTYPE(v)	(NTYPE(v) == GOVX )$/
BRK	3.def.h	/^#define BRK(v)	FATH(v)		\/* lexical successor of v,/
CHILDNUM	def.h	/^#define CHILDNUM(v)	childper[NTYPE(v)]$/
CODELINES	def.h	/^#define CODELINES(v)		*vxpart(v,STLNVX,2)		\/* # of/
DEFINED	def.h	/^#define DEFINED(v)	(v >= 0)$/
EXP	def.h	/^#define EXP(v)	*expres(v)		\/* expression - ASVX, C/
FATH	def.h	/^#define FATH(v) *vxpart(v,ITERVX,1)		\/* father of /
FMTREF	def.h	/^#define FMTREF(v)	*vxpart(v,IOVX,0)	\/* FMTVX assoc/
FORMCASE	3.loop.c	/^#define FORMCASE(w)	(DEFINED(w) && !DEFINED(RSIB(w/
HASBRACE	4.def.h	/^#define HASBRACE(v,i)	 ((DEFINED(LCHILD(v,i))) ? b/
HASLEX	3.flow.c	/^#define HASLEX(t)	(t != GOVX && t != COMPVX && t !/
IFTHEN	3.def.h	/^#define IFTHEN(v)		( NTYPE(v) == IFVX && !DEFINED(/
INC	def.h	/^#define INC(v)	*vxpart(v,DOVX,0)		\/* string for it/
LABEL	3.def.h	/^#define LABEL(v)	REACH(v)$/
LABREF	def.h	/^#define LABREF(v)	*vxpart(v,ASVX,1)		\/* node refer/
LCHILD	def.h	/^#define LCHILD(v,i)	*lchild(v,i)$/
LEVEL	def.h	/^#define LEVEL(v)	*level(v)$/
LPRED	def.h	/^#define LPRED(v) *vxpart(v,ITERVX,2)		\/* loop pred/
MARK	2.dfs.c	/^#define MARK(v)	{REACH(v) = 1; }	\/* mark node v *\//
MARKED	2.dfs.c	/^#define MARKED(v)	(REACH(v))$/
MKEDGE	2.dfs.c	/^#define MKEDGE(e)	{if (e >= -1) e = -(e+3); }	\/* m/
Mbeauty	beauty.y	/^main()$/
Mmain	main.c	/^main(argc,argv)$/
NEG	def.h	/^#define NEG(v)			*negpart(v)		\/* TRUE if predicate/
NOBRACE	4.def.h	/^#define NOBRACE(v,i)	{ if (DEFINED(LCHILD(v,i))) b/
NTYPE	def.h	/^#define NTYPE(v)	graph[v][0]$/
NUM	3.reach.c	/^NUM(v)$/
NXT	def.h	/^#define NXT(v)	*vxpart(v,ITERVX,0)		\/* THENVX cont/
ONDISK	def.h	/^#define ONDISK(v)	*stlfmt(v,1)		\/* FALSE if in cor/
OUTNUM	4.def.h	/^#define OUTNUM(x)		fprintf(outfd,"%d",x)$/
OUTSTR	4.def.h	/^#define OUTSTR(x)		fprintf(outfd,"%s",x)$/
POSTRW	def.h	/^#define POSTRW(v)	*vxpart(v,IOVX,2)	\/* string occu/
PRED	def.h	/^#define PRED(v)		*predic(v)	\/* string containing p/
PRERW	def.h	/^#define PRERW(v)	*vxpart(v,IOVX,1)	\/* string occur/
REACH	def.h	/^#define REACH(v)	graph[v][3]$/
RECURSE	3.def.h	/^#define RECURSE(p,v,r)	{ for (r = 0; r < CHILDNUM(/
RSIB	def.h	/^#define RSIB(v)	graph[v][2]$/
SETNUM	3.reach.c	/^SETNUM(v,count)$/
TABOVER	4.def.h	/^#define TABOVER(n)	tabover(n,outfd)$/
UNMARK	2.dfs.c	/^#define UNMARK(v)	{REACH(v) = 0; }$/
UNMKEDGE	2.dfs.c	/^#define UNMKEDGE(e)	{if (e < -1) e = -(e+3); }$/
YESBRACE	4.def.h	/^#define YESBRACE(v,i)	{ if (DEFINED(LCHILD(v,i))) /
accum	beauty.y	/^accum(token)		\/* fill output buffer, generate cont/
act	1.fort.c	/^act(k,c,bufptr)$/
addchar	1.line.c	/^addchar(c)$/
addlab	3.branch.c	/^addlab(v)		\/* add labels *\/$/
addloop	2.dfs.c	/^addloop()	\/* add LOOPVX, ITERVX at nodes entered b/
addref	1.hash.c	/^addref(x,ptr)				\/* put ptr in chain for x or assi/
addroot	tree.c	/^addroot(string,type,n1,n2)$/
addum	1.finish.c	/^addum(v,lst)$/
append	0.list.c	/^struct list *append(v,ls)		\/* return ls . v *\/$/
arc	0.parts.c	/^VERT *arc(v,i)$/
asoc	2.tree.c	/^asoc(v,n)		\/* return # of nodes associated with v /
balloc	0.alloc.c	/^balloc(n,p,size)		\/* allocate n bytes from coreblk/
bfree	0.alloc.c	/^bfree(p)		\/* free coreblk p *\/$/
blankline	1.form.c	/^blankline()$/
build	2.main.c	/^build()$/
challoc	0.alloc.c	/^challoc(n)$/
charout	4.form.c	/^charout(c)$/
checkneg	tree.c	/^checkneg(tree,neg)		\/* eliminate nots if possible /
chfree	0.alloc.c	/^chfree(p,n)$/
chkbranch	3.branch.c	/^chkbranch(v,head)$/
chreach	2.dfs.c	/^chreach()		\/* look for unreachable nodes *\/$/
classmatch	0.string.c	/^classmatch(c,i)$/
clear	1.hash.c	/^clear(x)$/
cntarcs	3.loop.c	/^cntarcs()	\/* count arcs entering each node *\/$/
comdom	2.dom.c	/^comdom(u,v,dom)			\/* find closest common dominator/
comfree	1.form.c	/^comfree(posafter)$/
compcase	1.recog.c	/^compcase(ifflag)		\/* turn computed goto into case /
compound	4.brace.c	/^compound(v,ch)		\/* return TRUE iff subpart ch of v/
comprint	4.form.c	/^comprint()$/
comstand	1.form.c	/^comstand(posafter)			\/* standard form comments *\/$/
concat	0.string.c	/^concat(x,y)			\/* allocate space, return xy *\/$/
connect	1.hash.c	/^connect(x,y)$/
consls	0.list.c	/^struct list *consls(v,ls)		\/* make list *\/$/
contfree	1.form.c	/^contfree()			\/* identify continuation lines in fre/
contin	1.recog.c	/^contin(labe,nest)		\/* handle continue statements */
contstand	1.form.c	/^contstand()			\/* continuation lines in standard fo/
copychars	0.string.c	/^copychars(cbeg,target,n)		\/* copy n chars from cbe/
copycs	0.string.c	/^copycs(cbeg,target,n)			\/* copy n chars from cbeg /
create	0.parts.c	/^create(type,arcnum)$/
dexit	main.c	/^dexit()$/
dfs	2.dfs.c	/^dfs(v)		\/* depth first search *\/$/
distinct	1.recog.c	/^distinct(vlist,count,dlist,size)		\/* make dlist in/
empseek	1.form.c	/^empseek(linebeg)$/
error	beauty.y	/^error(mess1, mess2, mess3)$/
exchange	2.dfs.c	/^exchange(p1,p2)		\/* exchange values of p1,p2 *\/$/
exits	3.reach.c	/^exits(v)	\/* set REACH(v) = w if w is only node out/
expres	0.parts.c	/^int *expres(v)$/
faterr	0.alloc.c	/^faterr(mess1, mess2, mess3)$/
find	0.string.c	/^find(s,ar,size)$/
fingraph	1.finish.c	/^fingraph()$/
fixflow	3.flow.c	/^fixflow(v,autolex)$/
fixhd	3.loop.c	/^fixhd(v,hd,head)$/
fiximp	1.node.c	/^fiximp(num,labe)		\/* fix implicit links, check nes/
fixloop	3.loop.c	/^fixloop(v)		\/* find WHILE loops  *\/$/
fixvalue	1.hash.c	/^fixvalue (x,ptr)$/
flush	1.line.c	/^flush()$/
forst	beauty.y	/^forst()$/
freegraf	0.alloc.c	/^freegraf()$/
freelabs	1.fort.c	/^freelabs()$/
freelst	0.list.c	/^freelst(ls)$/
freenode	tree.c	/^freenode(treenode)$/
freetree	tree.c	/^freetree(tree)$/
galloc	0.alloc.c	/^galloc(n)		\/* allocate from graph storage area *\/$/
getargs	0.args.c	/^char *getargs(argc, argv)$/
getbranch	3.branch.c	/^getbranch(head)$/
getdom	2.dom.c	/^getdom(inarc,dom)$/
getflow	3.flow.c	/^getflow()$/
gethead	2.head.c	/^gethead(head)$/
getinarc	2.inarc.c	/^getinarc(inarc,head)		\/* construct array "inarc" c/
getline	1.line.c	/^getline(lastline,lastchar,linecom,charcom)$/
getloop	3.loop.c	/^getloop()$/
getreach	3.reach.c	/^getreach()		\/* obtain REACH(v) for each node v *\/$/
getswitch	3.loop.c	/^getswitch(v)$/
getthen	3.then.c	/^getthen(v)		\/* turn IFVX into THEN when appropriat/
gettree	2.tree.c	/^gettree(inarc,dom,head)		\/* build tree *\/$/
getun	3.loop.c	/^getun(v)		\/* change loop to REPEAT UNTIL if possib/
getwh	3.loop.c	/^getwh(v)$/
graf_init	1.init.c	/^graf_init()$/
hash	1.hash.c	/^hash(x)$/
hash_check	1.hash.c	/^hash_check()$/
hash_free	1.hash.c	/^hash_free()$/
hash_init	1.hash.c	/^hash_init()$/
inchar	1.form.c	/^inchar()$/
innerdo	1.recog.c	/^innerdo(labe)		\/* return number of DOVX associated/
input1	1.line.c	/^input1()$/
input2	4.form.c	/^input2()$/
insib	2.tree.c	/^insib(w,v)		\/* make RSIB(w) = v, and make RSIB(rig/
insloop	2.dfs.c	/^insloop(v)		\/* insert LOOPVX, ITERVX at node numbe/
inspr	3.reach.c	/^LOGICAL inspr(w,pr)		\/* insert w in order in pr, r/
label	1.fort.c	/^long label(i)$/
labfree	1.form.c	/^labfree(func)			\/* labels in freeform input *\/$/
labstand	1.form.c	/^labstand(func)			\/* labels in standard form input /
lchild	0.parts.c	/^VERT *lchild(v,i)$/
level	0.parts.c	/^int *level(v)$/
lexval	3.flow.c	/^lexval(v,lastlex)$/
line_init	1.init.c	/^line_init()$/
loomem	2.inarc.c	/^loomem(x,y,head)			\/* return TRUE if x is in loop /
lowanc	2.head.c	/^lowanc(y,z,head)		\/* find the first node in chain /
lslen	0.list.c	/^lslen(ls)		\/* return number of elements in list ls/
makebr	3.flow.c	/^makebr(w)		\/* make branching node leading to w *\/$/
makeif	1.recog.c	/^makeif(first,labe,test,arc1,arc2)			\/* construct I/
makelab	1.fort.c	/^struct lablist *makelab(x)$/
makenode	1.node.c	/^makenode(type,addimp,addcom, labe,arcnum,arctype,a/
maxentry	2.inarc.c	/^maxentry(x,y,head)	\/* return z if z is ITERVX of l/
merge	2.head.c	/^merge(w,y,head)		\/* merge chains of w and y accord/
mkgraph	1.main.c	/^mkgraph()$/
mkthen	3.then.c	/^mkthen(v)$/
morespace	0.alloc.c	/^morespace(n,p,size)		\/* get at least n more wds fo/
ndbrace	4.brace.c	/^ndbrace(v)			\/* determine whether braces needed ar/
negate	3.then.c	/^negate(v)$/
negpart	0.parts.c	/^int *negpart(v)$/
nesteddo	1.recog.c	/^nesteddo(labe,v)$/
newlevel	4.out.c	/^newlevel(v,ch,tab,tabfirst)$/
newline	beauty.y	/^newline()$/
nonblchar	1.form.c	/^nonblchar(class,yesno)$/
null	4.form.c	/^null(c)$/
number	3.reach.c	/^number(v)$/
nxtlab	3.branch.c	/^nxtlab()$/
oneelt	0.list.c	/^oneelt(ls)		\/* return w if w is only elt of ls, UN/
output	4.main.c	/^output()$/
outrat	4.out.c	/^outrat(v,tab,tabfirst)$/
parse	1.hash.c	/^parse()$/
pop	beauty.y	/^pop()$/
prcode	4.form.c	/^prcode(linecount,tab)$/
prcom	4.out.c	/^prcom(v)$/
prec	tree.c	/^prec(oper)$/
predic	0.parts.c	/^int *predic(v)$/
prgraph	0.graph.c	/^prgraph()$/
prlab	4.out.c	/^prlab(n,tab)$/
prline	4.form.c	/^prline(str)$/
prlst	0.list.c	/^prlst(ls)$/
prog_init	1.init.c	/^prog_init()$/
prpred	4.out.c	/^prpred(v,addpar)$/
prstln	4.out.c	/^prstln(v,tab)$/
prtr	0.graph.c	/^prtr(v,tab)		\/* print tree in form of program inde/
prtree	0.graph.c	/^prtree()$/
push	beauty.y	/^push(type)$/
putout	beauty.y	/^putout(type,string)			\/* output string with proper/
puttree	tree.c	/^puttree(tree)$/
rdfree	1.form.c	/^rdfree(func)$/
rdstand	1.form.c	/^rdstand(func)$/
recognize	1.recog.c	/^recognize(type, ifflag)			\/* if ifflag = 1, statem/
remtilda	1.fort.c	/^remtilda(s)			\/* change ~ to blank *\/$/
repsearch	2.dfs.c	/^repsearch(v)		\/* repeat df search in order to fill/
reuse	0.alloc.c	/^reuse(p)		\/* set nxtfree so coreblk can be reused /
routinit	1.init.c	/^routinit()$/
search	2.dfs.c	/^search(v)$/
setsw	0.args.c	/^setsw(str)$/
slength	0.string.c	/^slength(s)			\/* return number of chars in s, not c/
stlfmt	0.parts.c	/^int *stlfmt(v,n)$/
str_copy	0.string.c	/^str_copy(s,ptr,length)	\/* copy s at ptr, return le/
str_eq	0.string.c	/^str_eq(s,t)$/
stralloc	1.fort.c	/^stralloc(ad,n)			\/* allocate space, copy n chars f/
strerr	0.alloc.c	/^strerr(mess1, mess2, mess3)$/
structure	3.main.c	/^structure()$/
tab	beauty.y	/^tab(n)$/
tabover	0.graph.c	/^tabover(n,fd)		\/* tab n times *\/$/
talloc	0.alloc.c	/^talloc(n)		\/* allocate from line-by-line storage a/
unchar	1.form.c	/^unchar(c)$/
unput1	1.line.c	/^unput1(c)$/
unput2	4.form.c	/^unput2(c)$/
uptolow	1.form.c	/^uptolow(c)		\/*translates upper to lower case *\/$/
vxpart	0.parts.c	/^int *vxpart(v,type,j)$/
yield	tree.c	/^yield(tree,fprec)$/
yyerror	beauty.y	/^yyerror(s)$/
yyinit	beauty.y	/^yyinit(argc, argv)			\/* initialize pushdown store /

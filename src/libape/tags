afree_	shortran.c	/^afree_(a)$/
aperror	util.c	/^aperror(s) char *s;$/
even	shift.c	/^#define even(n)		!odd(n)$/
fmin	mout.c	/^fmin(a,f) MINT *a; FILE *f;$/
fmout	mout.c	/^fmout(a,f) MINT *a; FILE *f;$/
gcd	gcd.c	/^gcd(a,b,c)$/
gcd_	shortran.c	/^gcd_(a,b,c)$/
itom_	shortran.c	/^itom_(n,a)$/
lpow	pow.c	/^lpow(m,n,b)$/
lshift	shift.c	/^lshift(a,amount)	\/* left shift a by amount words -/
ltom	util.c	/^MINT *ltom(ln)$/
m_add	madd.c	/^m_add(a,b,c)$/
m_div	mdiv.c	/^m_div(a,b,q,r)  \/* basic "long division" routine */
m_dsb	mdiv.c	/^m_dsb(q,n,a,b)$/
m_in	min.c	/^m_in(a,b,f)  \/* input a number base b from file f /
m_mult	mult.c	/^m_mult(a,b,c) \/* c = a * b for 0 <= a <= b *\/$/
m_out	mout.c	/^m_out(a,b,f)  \/* output a base b onto file f *\/$/
m_sub	madd.c	/^m_sub(a,b,c)$/
m_trq	mdiv.c	/^m_trq(v1,v2,u1,u2,u3)$/
madd	madd.c	/^madd(a,b,c)  \/* c = a + b; keeps track of sign, et/
madd_	shortran.c	/^madd_(a,b,c)$/
makemint	util.c	/^makemint(a,ln)$/
mcan	util.c	/^mcan(a)$/
mcmp	util2.c	/^mcmp(a,b)$/
mdiv	mdiv.c	/^mdiv(a,b,q,r)  \/* q = quotient, r = remainder, of /
mdiv_	shortran.c	/^mdiv_(a,b,c,d)$/
minput	mout.c	/^minput(a) MINT *a;$/
minput_	shortran.c	/^minput_(a,i)	\/* Name can't be "min" because of For/
mout	mout.c	/^mout(a) MINT *a;$/
mout_	shortran.c	/^mout_(a)$/
move	util.c	/^move(a,b)$/
mshift	shift.c	/^mshift(a,answer,amount) \/* same as lshift, except /
msqrt	msqrt.c	/^msqrt(a,b,r) \/* b = square root of a - r, where r /
msub	madd.c	/^msub(a,b,c)$/
msub_	shortran.c	/^msub_(a,b,c)$/
mtovec_	shortran.c	/^mtovec_(a,length,vect)$/
mult	mult.c	/^mult(a,b,c)  \/* c = a * b *\/$/
mult_	shortran.c	/^mult_(a,b,c)$/
new	util.c	/^new(pa)$/
new_	shortran.c	/^new_(n)$/
odd	shift.c	/^#define odd(n)		((n)&01)$/
oddpart	shift.c	/^oddpart(a)	\/* replace a by its odd part, returning/
om_out	mout.c	/^om_out(a,f)	\/* Output a base 8 onto file f; this i/
omin	mout.c	/^omin(a) MINT *a;$/
omin_	shortran.c	/^omin_(a,i)$/
omout	mout.c	/^omout(a) MINT *a;$/
omout_	shortran.c	/^omout_(a)$/
outlength	mout.c	/^outlength(a,b)$/
padd	pointers.c	/^PMINT padd(a,b)$/
pdiv	pointers.c	/^PMINT pdiv(a,b)$/
pgcd	pointers.c	/^PMINT pgcd(a,b)$/
pmod	pointers.c	/^PMINT pmod(a,b)$/
pmult	pointers.c	/^PMINT pmult(a,b)$/
pow	pow.c	/^pow(a,b,c,d) \/* d = a^b mod c; c needed to prevent/
pow_	shortran.c	/^pow_(a,b,c,d)$/
powerof2	shift.c	/^powerof2(a,n)		\/* a = a*2^n *\/$/
ppow	pointers.c	/^PMINT ppow(a,b,c)$/
prpow	pointers.c	/^PMINT prpow(a,n)$/
psdiv	pointers.c	/^PMINT psdiv(a,n)$/
psqrt	pointers.c	/^PMINT psqrt(a)$/
psub	pointers.c	/^PMINT psub(a,b)$/
reciprocal	gcd.c	/^reciprocal(a,n,b)$/
remsqrt	pointers.c	/^PMINT remsqrt(a)$/
rpow	pow.c	/^rpow(a,n,b)$/
rpow_	shortran.c	/^rpow_(a,b,c)$/
rshift	shift.c	/^rshift(a,amount)	\/* right shift a by amount words /
s_div	mdiv.c	/^s_div(a,n,q,r)  \/* dirtywork function for sdiv *\/$/
sdiv	mdiv.c	/^sdiv(a,n,q,r)  \/* q is quotient, r remainder of a\//
sdiv_	shortran.c	/^sdiv_(a,b,c,d)$/
shtom	util.c	/^MINT *shtom(n)$/
simpleconvert	min.c	/^simpleconvert(a,b,s)$/
sm_in	min.c	/^sm_in(a,b,s)	\/* like m_in, but for a number repres/
sm_out	mout.c	/^sm_out(a,b,s)$/
smod	pointers.c	/^smod(a,n)$/
square	square.c	/^square(a,b)	\/* b = a^2, recursive version *\/$/
stom	util2.c	/^PMINT stom(str)$/
stom_	shortran.c	/^stom_(str,a,strlength)$/
tradd	mult.c	/^tradd(a,b,c)$/
vectom_	shortran.c	/^vectom_(length,vect,a)$/
xalloc	util.c	/^short *xalloc(nint,s)$/
xfree_	shortran.c	/^xfree_(a)$/
